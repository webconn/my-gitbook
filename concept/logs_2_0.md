# Логи 2.0

Цель - структурировать логи и минимальными усилиями увеличить количество информации, которую можно получить из логов, а также сделать работу с ними более удобной для пользователей, в том числе неопытных.

### Метаинформация

В записи логов можно добавлять метаинформацию, которая позволит быстрее и точнее локализовать проблемы.

Что добавится в логи:

* ID запуска программы \(PID + ID в формате UUID, чтобы различать запуски в том числе между перезагрузками. К тому же в ходе работы программы могут появляться подпроцессы с разными PID, но UUID должен оставаться одинаковым для всех подпроцессов\);
* категория сообщения для удобной фильтрации \(по компонентам и подсистемам, в строковом формате; например, `serial/bus1/device1`\);
* ID сообщения \(отражающее конкретное место, в котором оно формируется. Больше важно для диагностик, чем для обычных записей в лог\);
* файл и строка в файле, где делается вывод;
* версия программы \(хеш коммита и, возможно, строка с номером версии пакета в формате debian\);
* другие метаданные \(например, значения контрольных величин, которые дальше можно передать в мониторинг для сбора метрик\).

Метаинформация добавляется в логи по возможности в бинарном формате, чтобы уменьшить объём хранимых данных и позволить БД с логами быстро индексировать сообщения \(например, по ID\).

### Настройка логгирования для сервисов

Сейчас в сервисах Wiren Board есть огромная проблема с настройкой логгирования. Некоторые настройки вводятся через конфиг, некоторые - через аргументы командной строки \(при этом настроить их неопытному пользователю сложно, да и опытный не получает удовольствия от перезапуска процесса руками с другими аргументами, особенно когда для этого нужно гасить процесс, запущенный через `systemd`\).

Потому следует унифицировать и проработать механизм настройки логгера на уровне `libwbmqtt`/`wbgo` таким образом, чтобы все процессы настраивались одинаково, при этом это не требовало бы отдельных усилий от программиста. Вплоть до того, что настройка логгирования через командную строку должна быть отключена совсем или делаться вызовом вроде `WbMqttDriver::Init(&argc, &argv)`, который будет сам находить нужные аргументы, настраиваться по ним и убирать их из `argv`, чтобы не смущать дальнейшую инициализацию процесса.

Я считаю, что настройку логгирования также нужно убирать из конфига сервиса \(убрать галочку `Enable debugging output` из JSON\) и вывести их в отдельный конфиг, который будет считываться при запуске сервиса на уровне общей библиотеки. \(например, из файлов `/etc/wb-logging/$SERVICE_NAME.conf`, которые к тому же не создавать по умолчанию, а только при необходимости что-то поменять в поведении логов\).

Более того, в некоторых случаях хочется иметь возможность быстро включить более подробный вывод в логи для отладки конкретной подсистемы. Для этого можно сделать MQTT-RPC вызовы для каждого сервиса типа `set_logger`, в котором прописывать уровень логгирования для отдельной категории и, таким образом, получить возможность быстро настраивать логи во время выполнения, без необходимости перезапускать процесс.

Например, для сервиса `daemons/wb-mqtt-serial/logger`:

```text
set_logger('/serial/bus1', 'debug')
```

включит вывод всех сообщений уровня `debug` и выше в подсистемах, связанных с шиной `bus1`.

Также для упрощения написания интерфейса настройки нужно сделать вызов `get_loggers`, который выведет все доступные подкатегории для заданной категории, а также выставленные уровни логгирования в них.

### Stacktrace

При падении сервиса хочется получить максимум информации в одном месте, чтобы по возможности избежать сложного разбора полётов. Логи кажутся неплохим местом для хранения такой информации.

Один из хороших источников такой информации - это текущий стек \(stacktrace\). В C++ он не всегда формируется очевидно. Для программ на Go стектрейс при падении получить гораздо проще.

> Автор помнит ситуацию, когда для получения стектрейса при падении процесса программы на Go \(кажется, это был wb-rules\) приходилось городить страшную конструкцию из ptrace и awk/sed, которая потом даже была обёрнута в скрипт. На это ушло немало времени, и использование этой штуки крайне неудобно и неочевидно, особенно для неопытного пользователя.

Нужно проработать идею сбора отладочных данных о падении и выгрузке их в лог, даже если это будет не единообразно для разных языков.

### Ротация по умолчанию

Сейчас система сбора логов в Wiren Board настроена недостаточно продуманно, в том числе в части складывания их в файлы, ротации и так далее. Это приводит к неприятным ситуациям, когда логи начинают внезапно заполнять всё пространство на пользовательском разделе из-за того, что забыли отключить отладочный вывод в `wb-mqtt-serial` \(на форуме есть топик про то, как из-за этого сломался редактор скриптов в интерфейсе\).

Хочется избежать возможности возникновения подобных ситуаций в будущем. Для этого нужно изучить возможности настройки ротации логов в `journald`, при этом по возможности сделать так, чтобы отладочный вывод какой-нибудь программы не мог "забить" лог, из-за чего потеряются более редкие и важные сообщения. В идеале ротация должна настраиваться отдельно для каждого сервиса \(или даже категории\) и уровня логгирования.

Настройки по умолчанию должны быть такими, чтобы от неосторожных действий пользователя, которые он может сделать через web-интерфейс \(вроде включения отладочного вывода\) контроллер не взрывался ни при каких обстоятельствах! При этом учесть, что в эти настройки никто в здравом уме никогда сам не полезет.

Если для этого не хватит штатных возможностей `journald`, можно использовать сторонний сборщик логов вроде [Fluent Bit](https://fluentbit.io/), у которого подобные штуки настраиваются крайне гибко.

### One-click выгрузка логов

Идея вдохновлена подобной фичей во многих enterprise-системах \(вроде дисковых массивов или серверов\). В интерфейсах таких систем часто есть кнопка "выгрузить логи", при нажатии на которую последние логи складываются в архив и скачиваются на компьютер пользователя. При появлении проблем такой архив можно отправить в техподдержку.

С учётом нормально работающей ротации, у этого архива будет более или менее ожидаемый \(небольшой\) размер и одинаковая структура.

Это удобно тем, что пользователю не надо будет лазить по закромам файловой системы \(в результате чего каких-то логов может ещё и не хватить\), а инженерам не надо будет вспоминать, какие логи нужно попросить у пользователя и где они лежат. Более того, можно будет сделать специальную систему для просмотра и анализа логов для инженера техподдержки, а может быть, и бота, который будет находить типовые проблемы и автоматически отвечать на форум или в чат.

